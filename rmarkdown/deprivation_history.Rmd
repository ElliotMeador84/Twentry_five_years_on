---
title: "Historical Deprivation"
author: "Elliot Meador"
date: "24/10/2019"
output: word_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```






```{r scratch, echo=F, message=F, warning=F}
library(ggplot2)
library(tidyverse)
library(janitor)
library(ggsci)
library(openxlsx)
library(corrplot)

source('/Users/emeador/OneDrive - SRUC/all_functions.R')

pop_theme <- theme_bw()+
    theme(text = element_text(size = 13.5, 
                              color = 'black'), 
          panel.grid.minor = element_blank(), 
          axis.title.y = element_text(angle = 0, hjust = 1, face = 'italic'),
          plot.margin = margin(1,1,1,1, 'cm'), 
          strip.background = element_blank(), 
          strip.text.y = element_text(angle = 0, hjust = 0), 
          legend.position = 'bottom', 
          plot.caption = element_text(hjust = 0, face= "italic"), #Default is hjust=1
        plot.title.position = "plot", #NEW parameter. Apply for subtitle too.
        plot.caption.position =  "plot")




case_study_cols <- c(Spectral[c(1, 4, 11, 11)], Greys[c(4, 4)])

names(case_study_cols) <- c('Perthshire', 
                            'Northumberland', 
                            'Eilean Siar', 
                            'Na h-Eileanan Siar', 
                            'Rest of Scotland', 
                            'Rest of England')



scotland_files <- list.files('/Users/emeador/OneDrive - SRUC/Data/deprivation/scotland/historic/', full.names = T)

scotland_lookup <- read_csv('/Users/emeador/OneDrive - SRUC/Data/lookup/Local_authority_dz_int_lookup.csv') %>% 
    clean_names()

england_files <- list.files('/Users/emeador/OneDrive - SRUC/Data/deprivation/england/historic/', full.names = T)


england_df_ls <- map(england_files, function(x){
    read_csv(x) %>% 
       clean_names() 
        
})

scotland_df_ls <- map(scotland_files, function(x){
    read_csv(x) %>% 
       clean_names() 
        
})


    #### Scotland ####

scotland_deprivation_scores.i <- map2(scotland_df_ls, c(2009,2012,2016), function(.x, .y){
 y <-    .x %>% 
        select(datazone = contains('data_zone'), 
               income_rate = contains('inc_rate'), 
               contains('_rate'), 
               contains('_score'))
 y %>% 
     select(names(y)) %>% 
     mutate(year = .y)
}) 


scotland_deprivation.i <- scotland_deprivation_scores.i %>% 
    map(function(x){
     names(x) <-    names(x) %>% 
            str_remove_all('[:digit:]') %>% 
            str_remove_all('^simd') %>% 
            str_remove_all('^v') %>% 
            str_remove_all('_')
     x %>% 
         select(order(names(x))) 
     
    }) %>% 
    bind_rows()



datazone_lookup <- read_csv('/Users/emeador/OneDrive - SRUC/Data/lookup/scotland_datazone_2001_2011.csv') 







scotland_deprivation_scores <- 
    scotland_deprivation.i %>% 
    left_join(datazone_lookup %>% 
  select(datazone = value, local_authority)) %>% 
  select(-crimerate, -crimescore)





scotland_deprivation_scores <- scotland_deprivation_scores %>% 
  gather(key, value, -local_authority, -year, -datazone) %>% 
  drop_na(local_authority) %>% 
  mutate(key = case_when(
    str_detect(key, 'accessscore') ~ 'Access\n(Average drive time to services)',
    str_detect(key, 'educscore') ~ 'Education\n(Pupal attendance, attainment of leavers, working-age without\nqualifications)',
    str_detect(key, 'emprate') ~ 'Employment\n(Proportion of people who are income deprived)',
    str_detect(key, 'hlthscore') ~ 'Health\n(Composite of health indicators)',
    str_detect(key, 'housescore') ~ 'Health\n(Proportion overcrowding and no heat)',
    str_detect(key, 'incomerate') ~ 'Income\n(Proportion of working-age who are employment deprived)',
  )) %>% 
  mutate(case_study = case_when(
    str_detect(local_authority, 'Perth and Kinross')~'Perthshire', 
    str_detect(local_authority, 'Na h-Eileanan an Iar')~'Na h-Eileanan Siar',
    T ~ 'Rest of Scotland'
  )) 





    #### England ####


names(england_df_ls[[1]])[10] <- 'income_score_rate'
names(england_df_ls[[1]])[12] <- 'employment_score_rate'



england_like_names <- names(england_df_ls[[1]]) %>% 
    intersect(names(england_df_ls[[2]])) %>% 
    intersect(names(england_df_ls[[3]]))




england_df_ls.i <- map2(england_df_ls, c(2009,2015,2019), function(x, y){
   x %>% 
        select(post_2009_la_na = contains('name'), 
               england_like_names, 
               contains('income_')) %>% 
       rename(local_authority = post_2009_la_na2) %>% 
       select(-post_2009_la_na1) %>% 
       mutate(year = y)
})



england_deprivation_scores <- england_df_ls.i %>% 
    bind_rows()



england_tidy <- england_deprivation_scores %>% 
  select(-contains('rank')) %>% 
  gather(key, value, -local_authority, -year) %>% 
  mutate(case_study = case_when(
    str_detect(local_authority, 'Northumberland') ~ 'Northumberland', 
    T ~ 'Rest of England'
  )) %>% 
  mutate(key = str_replace_all(key, '_', ' '), 
         key = str_to_title(key),
         key = str_remove_all(key, 'Score'), 
         key = str_squish(key)) %>% 
  filter(!str_detect(key, 'Sub')) %>% 
  mutate(key = case_when(
    str_detect(key, 'Income Rate') ~ 'Income Rate\n(Proportion of popualtion out-of-work or have low earnings)', 
    str_detect(key, 'Employment Rate') ~ 'Employment Rate\n(Propotion of working-age population that is involuntarily\nexcluded fom labour market)', 
    str_detect(key, 'Education Skills And Training') ~ 'Education Skills and Training\n(Lack of attainment and skills in population)', 
    str_detect(key, 'Health Deprivation And Disability') ~ 'Health Deprivation and Disability\n(Risk of premature death and impairment of quality of life)', 
    str_detect(key, 'Barriers To Housing And Services') ~ 'Barriers to Housing and Services\n(Physical and Financial accessibility of housing and local services)', 
    str_detect(key, 'Living Environment') ~ 'Living Environment\n(Measures the quality of the local environment)'
  ))



```


# Deprivation overview

England and Scotland both have their own versions of an index of multiple deprivation, known as the IMD and SMID respectively. Both indexes rank small-area output regions based on scores pulled from seven domains. They are

1. Income
2. Employment
3. Educational attainment
4. Distance to services
5. Health deprivation
6. Crime deprivation
7. Housing deprivation

These indeces are quite similar in their approach to data collection, aggregation and analysis, though there are some differences which do not allow these data to compared directly. These include:

1. Differing data aggregation levels - In Scotland these are datazones and England these are lower layer super output areas; and,
2. Slightly different approaches to measuring each type of deprivation. 
3. Indeces are published on different years. 


There are different ways to show the data below. We can:

1. Show percentage change from base year (earliest year) - this makes it easier to discuss at an aggregate level and we can more easily compare changes across metrics and countries.
2. Each case study area can be mapped to show change over time - so have a map for case study and for each year. This is another way to show what is below (specific change over time.)

# Findings over time

## Scotland

```{r scotland-facet-imd, echo=F, message=F, warning=F, fig.width=11, fig.height=11}



scotland_deprivation_gg <- scotland_deprivation_scores %>% 
  ungroup() %>%
  group_by(case_study,key, year) %>% 
  summarise(median = median(value, na.rm = T)) %>% 
  ggplot(aes(year, median, group = case_study, color = case_study))+
  geom_line(size = 1.75)+
  geom_point(size = 4.85)+
  scale_color_manual(values = case_study_cols, 
                     labels = c('Outer Hebrides', 
                                'Perth and Kinross', 
                                'Rest of Scotland'))+
  scale_x_continuous(breaks = 2009:2019)+
  facet_wrap(~key, ncol = 2, scales = 'free_y')+
  pop_theme +
  labs(title = 'Comparing Scottish Domains of Deprivation Over Time', 
       x = 'Year', 
       y = 'Median\nvalue', 
       color = 'Case study Local Authority', 
       caption = 'NOTE: Varying scales on vertical axis.  Data are from the Scottish Indeces of Multiple Deprivation historical data.')


ggsave(scotland_deprivation_gg, filename = '/Users/emeador/OneDrive - SRUC/Twenty_five_years_on/png/scotland_deprivation.png', 
       height = 12, 
       width = 12)

scotland_deprivation_gg




```



## England
```{r england-facet-imd, echo=F, message=F, warning=F, fig.width=11, fig.height=11}


england_deprivation_gg <- england_tidy %>% 
  filter(!str_detect(key, 'Sub')) %>% 
  ungroup() %>%
  group_by(case_study,key, year) %>% 
  summarise(median = as.numeric(median(value, na.rm = T))) %>% 
  ggplot(aes(year, median, group = case_study, color = case_study))+
  geom_line(size = 1.5)+
  geom_point(size = 4.75)+
  scale_color_manual(values = case_study_cols)+
  scale_x_continuous(breaks = 2009:2019)+
  facet_wrap(~key, ncol = 2, scales = 'free_y')+
  pop_theme +
  labs(title = 'Comparing English Domains of Deprivation Over Time', 
       x = 'Year', 
       y = 'Median\nvalue', 
       color = 'Case study Local Authority', 
       caption = 'NOTE: Varying scales on vertical axis. Data are from the [England] Indeces of Multiple Deprivation historical data.')



ggsave(england_deprivation_gg, 
       filename = '/Users/emeador/OneDrive - SRUC/Twenty_five_years_on/png/england_deprivation_gg.png', 
       height = 12, 
       width = 12)

england_deprivation_gg



```


# Findings - correlations

Poverty is often experienced in myriad ways, with hardships in one area, like low income, causing hardships in others. One way to explore that is through correlation analysis. Correlations look at statistical relationships between two variables. In the following sections we look at correlations between factors around income and employment. 

The plots below show correlations between the deprivation in domains in Scotland and Wales. The cell text is the pearson correlation value. This can (loosely) be interpretted as:

1. 0 - 0.3 Low correlation
2. 0.31 - 0.6 Medium-strong correlation
3. 0.61 and above Strong correlation

Most correlations shown below are positive. This means that as one variable increases so does the corresponding variable. A negative sign (-) implies that as one variable increase the corresponding variable decreases.

In general, (especially in Scotland), deprivation is positively correlated to itself. The strongest correlation is between income and employment. The more employment deprived one is (usually) the more income deprived they are. Access to services is usually negatively correlated. This is likely due to the poorer neighbourhoods in more urban areas.

### Scotland

```{r scotland-corr, echo=F, message=F, warning=F, fig.width=10, fig.height=10}

scotland_dep_2016 <- scotland_deprivation_scores.i[[3]]



df <- scotland_dep_2016 %>%
  mutate_if(is.numeric, function(x)x+1) %>% 
  mutate_if(is.numeric, scale) %>% 
  select_if(is.numeric) %>%
  select(-year, -simd2016_crime_rate) %>% 
  na.omit()
  




M <- cor(df)


# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}


col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))


colnames(M) <- c('Income', 
                 'Employment', 
                 'Health',
                 'Education', 
                 'Housing', 
                 'Acesss')


row.names(M) <- colnames(M) 




corrplot(M, method="color", col=YlGnBu_n(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         p.mat = cor.mtest(df), sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=FALSE ,
          mar = c(1, 1, 1, 1)
         
         )



```



### England

```{r england-corr, echo=F, message=F, warning=F, fig.width=10, fig.height=10}


england_dep_2019 <- england_df_ls.i[[3]]




df <- england_deprivation_scores %>% 
  filter(year == 2019) %>% 
  select(-contains('rank')) %>% 
  select_if(is.numeric) %>% 
  select(-contains('decile'))%>%
  mutate_if(is.numeric, function(x)x+1) %>% 
  mutate_if(is.numeric, scale) %>% 
  select(income_score_rate, 
         employment_score_rate, 
         health_deprivation_and_disability_score, 
         education_skills_and_training_score, 
         barriers_to_housing_and_services_score, 
         living_environment_score, 
         indoors_sub_domain_score, 
         outdoors_sub_domain_score,
         geographical_barriers_sub_domain_score, 
         wider_barriers_sub_domain_score) %>% 
  set_names('Income', 'Employment', 'Health', 'Education', 'Housing', 'Living environment', 'Indoors environment', 'Outdoors environment', 'Geographical barriers', 'Wider barriers')









M <- cor(df)


# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}


col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))





corrplot(M, method="color", col=YlGnBu_n(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         # Combine with significance
         p.mat = cor.mtest(df), sig.level = 0.01, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag=FALSE ,
          mar = c(1, 1, 1, 1)
         
         )


```





































